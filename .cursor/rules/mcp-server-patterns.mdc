---
description: MCP server development patterns and best practices
---

# MCP Server Development Patterns

## MCP Protocol Overview

This project implements a **Model Context Protocol (MCP) server** that provides tools for interacting with Apple Reminders. The server follows MCP specifications and best practices.

## Server Architecture

### Core Components
- **Server**: [src/server/server.ts](mdc:src/server/server.ts) - MCP server setup and lifecycle
- **Handlers**: [src/server/handlers.ts](mdc:src/server/handlers.ts) - Request routing and processing
- **Tools**: [src/tools/](mdc:src/tools/) - Tool definitions and implementations
- **Prompts**: [src/server/prompts.ts](mdc:src/server/prompts.ts) - MCP prompt templates

### Tool Structure
```typescript
// Tool definition pattern
export const TOOLS: Tool[] = [
  {
    name: 'reminders',
    description: 'Comprehensive reminder management tool',
    inputSchema: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['create', 'update', 'delete', 'list'],
          description: 'Operation to perform'
        },
        // ... other properties
      },
      required: ['action']
    }
  }
];
```

## Tool Implementation Patterns

### Action-Based Design
Tools use an **action-based approach** rather than separate tools for each operation:

```typescript
// Single tool with multiple actions
const tool = {
  name: 'reminders',
  actions: ['create', 'update', 'delete', 'list', 'organize']
};

// Handler pattern
export async function handleReminderTool(args: ReminderToolArgs): Promise<ToolResponse> {
  switch (args.action) {
    case 'create':
      return await createReminder(args);
    case 'update':
      return await updateReminder(args);
    case 'delete':
      return await deleteReminder(args);
    case 'list':
      return await listReminders(args);
    default:
      throw new Error(`Unknown action: ${args.action}`);
  }
}
```

### Input Validation
All tool inputs are validated using Zod schemas:

```typescript
// Schema definition
const reminderCreateSchema = z.object({
  action: z.literal('create'),
  title: z.string().min(1).max(200),
  dueDate: z.string().regex(DATE_PATTERN).optional(),
  note: z.string().max(2000).optional(),
});

// Validation in handler
export async function createReminder(args: unknown): Promise<ToolResponse> {
  const validatedArgs = reminderCreateSchema.parse(args);
  // ... implementation
}
```

## Response Patterns

### Success Responses
```typescript
// Standard success response
const successResponse: ToolResponse = {
  content: [
    {
      type: 'text',
      text: 'Successfully created reminder: Buy groceries'
    }
  ],
  isError: false
};
```

### Error Responses
```typescript
// Standard error response
const errorResponse: ToolResponse = {
  content: [
    {
      type: 'text',
      text: 'Error: Invalid reminder title. Title cannot be empty.'
    }
  ],
  isError: true
};
```

### Structured Data Responses
```typescript
// List response with structured data
const listResponse: ToolResponse = {
  content: [
    {
      type: 'text',
      text: JSON.stringify({
        reminders: [
          {
            title: 'Buy groceries',
            list: 'Shopping',
            isCompleted: false,
            dueDate: '2024-01-01 18:00:00',
            notes: 'Don\'t forget milk and eggs'
          }
        ],
        total: 1,
        filter: { list: 'Shopping', showCompleted: false }
      })
    }
  ],
  isError: false
};
```

## Native Integration Patterns

### Dual Strategy Architecture
- **Read Operations**: Swift + EventKit for performance
- **Write Operations**: AppleScript for compatibility

```typescript
// Read pattern (Swift)
export async function listReminders(args: ListArgs): Promise<Reminder[]> {
  const binaryPath = getBinaryPath();
  const result = await executeBinary(binaryPath, args);
  return JSON.parse(result);
}

// Write pattern (AppleScript)
export async function createReminder(args: CreateArgs): Promise<void> {
  const script = buildCreateScript(args);
  await executeAppleScript(script);
}
```

### Binary Path Resolution
```typescript
// Multiple fallback paths
export function getBinaryPath(): string {
  const paths = [
    join(process.cwd(), 'dist', 'swift', 'bin', 'GetReminders'),
    join(process.cwd(), 'src', 'swift', 'bin', 'GetReminders'),
    join(process.cwd(), 'swift', 'bin', 'GetReminders'),
  ];
  
  for (const path of paths) {
    if (existsSync(path)) {
      return path;
    }
  }
  
  throw new Error('Swift binary not found');
}
```

## Prompt System

### Prompt Registry
```typescript
// Centralized prompt management
interface PromptRegistry {
  [Name in PromptName]: PromptTemplate<Name>;
}

const PROMPTS: PromptRegistry = {
  'daily-task-organizer': {
    name: 'daily-task-organizer',
    description: 'Organize daily tasks by priority',
    arguments: {
      sourceList: { type: 'string', description: 'Source list to organize' },
      strategy: { type: 'string', enum: ['priority', 'due_date'] }
    },
    messages: [
      createMessage('Organize my daily tasks by priority')
    ]
  }
};
```

### Prompt Usage
```typescript
// Prompt execution
export async function executePrompt(name: PromptName, args: unknown): Promise<PromptResponse> {
  const template = PROMPTS[name];
  if (!template) {
    throw new Error(`Unknown prompt: ${name}`);
  }
  
  const validatedArgs = template.arguments ? 
    z.object(template.arguments).parse(args) : {};
    
  return {
    messages: template.messages,
    arguments: validatedArgs
  };
}
```

## Error Handling Patterns

### Validation Errors
```typescript
// Input validation with detailed errors
export function validateReminderInput(input: unknown): ReminderInput {
  try {
    return reminderInputSchema.parse(input);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const messages = error.errors.map(err => 
        `${err.path.join('.')}: ${err.message}`
      );
      throw new Error(`Validation failed: ${messages.join(', ')}`);
    }
    throw error;
  }
}
```

### Native Integration Errors
```typescript
// Handle Swift binary errors
export async function executeSwiftBinary(args: string[]): Promise<string> {
  try {
    const result = await execFile(binaryPath, args);
    return result.stdout;
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new Error('Swift binary not found. Run npm run build first.');
    }
    throw new Error(`Swift execution failed: ${error.message}`);
  }
}
```

## Security Considerations

### Input Sanitization
```typescript
// Safe text pattern for AppleScript
const SAFE_TEXT_PATTERN = /^[\u0020-\u007E\u00A0-\uFFFF\n\r\t]*$/u;

// URL validation (prevents SSRF)
const URL_PATTERN = /^https?:\/\/(?!(?:127\.|192\.168\.|10\.|localhost|0\.0\.0\.0))[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?:\/[^\s<>"{}|\\^`[\]]*)?$/i;
```

### Permission Handling
```typescript
// Check system permissions
export async function checkPermissions(): Promise<boolean> {
  try {
    await executeAppleScript('tell application "Reminders" to get name of every list');
    return true;
  } catch (error) {
    return false;
  }
}
```

## Testing MCP Tools

### Tool Testing Pattern
```typescript
// Test tool handlers
describe('Reminder Tool Handler', () => {
  it('should create reminder with valid input', async () => {
    const args = {
      action: 'create',
      title: 'Test Reminder',
      dueDate: '2024-01-01'
    };
    
    const response = await handleReminderTool(args);
    
    expect(response.isError).toBe(false);
    expect(response.content[0].text).toContain('Successfully created');
  });
});
```

### Mock External Dependencies
```typescript
// Mock Swift binary
jest.mock('../utils/binaryPathInitializer.js', () => ({
  getBinaryPath: jest.fn().mockReturnValue('/mock/path'),
}));

// Mock AppleScript
jest.mock('../utils/applescript.js', () => ({
  executeAppleScript: jest.fn().mockResolvedValue('success'),
}));
```